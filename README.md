# GuaranteeSenderLib

## Описание

Библиотека предоставляет proxy-клиент, позволяющий минимизировать потери данных при Rest взаимодействии между двумя сервисами. Для промежуточного хранения данных предоставляется 3 типа буфера: SQL базы, NOSQL (MongoDb), Брокеры (Kafka). Очереди можно совмещать и комбинировать между собой по необходимости.

## Структура проекта

Проект состоит из 4-х основных модулей:

- **configuration-core** — общий модуль конфигурации. Здесь задается структура отправки через Rest и в очереди, здесь же находятся вспомогательные конфигурации для корректной работы.
- **pull-processing-core** — модуль, отвечающий за обработку сообщений в буфере, а также их очистку, если последняя не предусмотрена буфером.
- **signature-core** — модуль создания/проверки ЭЦП на основе pem/jks сертификатов.
- **guarantee-proxy** — модуль, являющийся входной точкой для клиента. В нем расположена логика балансировки нагрузки и circuitBreaker для Rest, а также общая логика взаимодействия и переключения между транспортами.

Также представлены два модуля `ClientExample` и `ServerExample` для демонстрации работы библиотеки.

### configuration-core

<img width="694" height="641" alt="image" src="https://github.com/user-attachments/assets/cf55caac-73e8-44b9-b06b-4a435c1341b4" />

`GuaranteeSenderConfiguration` — общая конфигурация для работы в модуле **guarantee-proxy**. Включает в себя список логических групп балансировки (`BalancingGroupConfiguration`), в исходной реализации это SQL, NOSQL и Broker группы.

Каждая `BalancingGroupConfiguration` включает в себя список провайдеров `BalancingProvider`, содержащих все необходимое для отправки в конкретную группу.

Для REST взаимодействий реализована балансировка нагрузки внутри провайдеров, с использованием указанного атрибута веса провайдера (`BalancingProvider.weight`). Также для REST взаимодействий реализованы CIRCUIT BREAKER и RETRY CONFIG.

<img width="847" height="654" alt="image" src="https://github.com/user-attachments/assets/7d2f1d6f-ca8a-40a1-8da9-d36f7523776e" />

Важным моментом является то, что на каждый хост REST взаимодействия используется свой `BalancingProvider`, т.к. требования по нагрузке, требования к повторным запросам могут варьироваться от сервера к серверу.

Для логического объединения буферов создавать несколько `BalancingProvider` не требуется, т.к. в библиотеке предусмотрена возможность использовать любое количество (и любую реализацию SQL БД), любое количество MongoDB.

Для KAFKA эта проблема не является актуальной, т.к. её единицей масштабирования являются кафка-брокеры.
Каждый BalancingProvider включает в себя реализацию интерфейса GuaranteeSender, который занимается отправкой по целевому транспорту. 

### pull-processing-core

Главной единицей взаимодействия в этом модуле является интерфейс `PullProcessing`, реализации которого предоставляют возможность повторного получения данных из буферов.

Все реализации работают в соответствии с расписанием, задаваемым клиентом с использованием CRON.

После получения неотправленных сообщений проводится проверка ЭЦП, в случае, если она не пройдена, сообщение повторно отправлено не будет.

По прохождении проверки, сообщение передается в `guarantee-proxy`, где повторно проходит попытку отправки.

<img width="507" height="362" alt="image" src="https://github.com/user-attachments/assets/f8c9473e-e7ed-4f2b-aa83-c941a603ffcd" />

Интерфейс `CleanProcessor` служит для очистки устаревших, уже отправленных данных. Реализации представлены для SQL, MongoDB. В Kafka очистка настраивается на стороне сервера посредством RETENTION POLICY.

<img width="635" height="357" alt="image" src="https://github.com/user-attachments/assets/5b772295-6e30-4054-a8b1-e8029561bb0a" />

`SchedulerConfiguration` сконфигурирована таким образом, что под процессы по расписанию выделяется отдельный пул потоков. Это позволяет сократить используемые приложением ресурсы.

### signature-core

<img width="545" height="291" alt="image" src="https://github.com/user-attachments/assets/3804e4b2-4002-43e6-9d90-b2ae98425d99" />

Модуль предоставляет возможность подписи отправляемых данных ЭЦП с использованием PEM / JKS сертификатов. В проекте предоставлен пример PEM сертификатов, сгенерированных командой:

openssl req -x509 \
  -newkey rsa:2048 \
  -keyout key.pem \
  -out cert.pem \
  -days 365 \
  -nodes \
  -subj "/CN=localhost" \
  -addext "subjectAltName = DNS:localhost,IP:127.0.0.1"

### guarantee-proxy 

Основной модуль — является точкой входа при попытке отправки данных.

При получении `GuaranteeSenderConfiguration` группы разбиваются на главную и буфер-группы. Главной группой по умолчанию является HTTP группа, остальные считаются буферами.

В цикле происходит балансировка нагрузки между `BalancingProvider` HTTP группы. В случае успешной отправки процесс заканчивается, иначе переходим к отправке в запасные буфер-группы.

Перед отправкой в БД или брокер данные обязательно подписываются ЭЦП, затем переходят к отправке в буфер, аналогично используя `BalancingProvider.sender`.

<img width="664" height="701" alt="image" src="https://github.com/user-attachments/assets/d812c963-be18-412f-b3d1-519551046e54" />

После вызова `GuaranteeSenderProxy.send()` все действия происходят в отдельном потоке. Для экономии ресурсов и оптимизации под отправку данных выделяется пул виртуальных потоков.

### Структура данных 

`GuaranteeSenderDto` — является единой сущностью, используемой внутри библиотеки для передачи и хранения данных. В случае с буфером структура таблиц полностью соответствует структуре этого ДТО, для REST взаимодействий данные десериализуются в сущность, которой параметризирован `GuaranteeSenderProxy<T>`.

<img width="465" height="192" alt="image" src="https://github.com/user-attachments/assets/8823f7a5-8340-472e-b4a1-9b089ace0f17" />

### Нефункциональные требования

В качестве логирования используется SLF4J, логируются все критически важные события, происходящие с данными, что позволяет легко отладить/просмотреть трассировку процесса.

Также в проекте используется ряд метрик, для настройки дашбордов в Grafana и Alerts. Отвечает за это пакет `monitoring` в модуле `configuration-core`.

По каждой метрике разделяются `FAIL` / `SUCCESS` события:

- **HTTP_SENDER** — метрика указывает на REST взаимодействие.
- **SQL_SENDER** — метрика указывает на SQL взаимодействие.
- **NO_SQL_SENDER** — метрика указывает на NO_SQL взаимодействие.
- **BROKER_SENDER** — метрика указывает на BROKER взаимодействие.
- **SQL_PULLER** — метрика указывает на операцию вычитки из SQL.
- **NO_SQL_PULLER** — метрика указывает на операцию вычитки из NO-SQL.
- **BROKER_PULLER** — метрика указывает на операцию вычитки из BROKER.
- **SQL_CLEANER** — метрика указывает на операцию очистки SQL БД.
- **NO_SQL_CLEANER** — метрика указывает на операцию очистки NO-SQL БД.
- **SIGN_DATA** — метрика указывает на операцию подписи данных (является критической).
- **SIGNATURE_CHECK** — метрика указывает на операцию проверки подписи данных (является критической).
- **GUARANTEE_SENDER** — метрика, отображающая FAIL операцию по всему процессу взаимодействия с гарантированной доставкой (цель: отобразить, что не удалось отправить ни в один буфер и данные потеряны, является критической).
- **TRANSPORT** — общая метрика, отображающая количество FAIL операций по транспортам.
